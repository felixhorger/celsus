#!/usr/bin/env python3
"""

	Celsus - Scientific reference manager for those with puristic taste.

"""

# Parse arguments
import argparse
parser = argparse.ArgumentParser(
	formatter_class=argparse.RawTextHelpFormatter
)
parser.add_argument("--description", action="store_true")
# Add the command subparser
subparsers = parser.add_subparsers(dest="command")
# use
parser_use = subparsers.add_parser(
	"use",
	help="Initialise a new repository or activate an existing one."
)
parser_use.add_argument(
	"path",
	metavar="PATH",
	type=str,
	default='.',
	help="to the repository."
)
# add
parser_add = subparsers.add_parser(
	"add",
	help="Add a document with corresponding unique key to the repository."
)
parser_add.add_argument(
	"--from",
	type=str,
	help=(
		"Directory from which to add *.pdf files recursively."
		+ " Positional arguments are ignored if set."
	),
	dest="from_dir"
)
parser_add.add_argument(
	"refs",
	metavar="REFS",
	nargs='*',
	type=str,
	help=(
	"List file1 key1 file2 key2 ... "
	"if adding fails, a message is written into stdout and the filename or key "
	"is written into stderr, depending on the error, no exception will be raised. "
	"If file is \"-\", it must be an arxiv paper which will be downloaded automatically. "
	"If key is \"-\", celsus will try to get the key from the file. "
	"Consequently, file must not be \"-\" in this case."
	)
)
# list
parser_list = subparsers.add_parser(
	"list",
	help="List matching references, see flags."
)
parser_list.add_argument(
	"keywords",
	metavar="KEYWORDS",
	nargs='*',
	type=str,
	help="List of keywords which must all be present "
	"in a matching bibtex entry (case sensitive)."
)
parser_list.add_argument("--key", action="store_true", help="Print the key.")
parser_list.add_argument(
	"--file",
	action="store_true",
	help="Print the path to the reference's file."
)
parser_list.add_argument("--nobib", action="store_true", help="Don't print the bibtex entry.")
parser_list.add_argument(
	"--open",
	action="store_true",
	help="Open the documents."
)
parser_list.add_argument(
	"--deep",
	action="store_true",
	help="Search the contents of the references as well."
	" It will enter interactive mode because loading all contents is slow."
	" The intended use is to review found documents and add them to a list, if matching."
	" This list can then be saved to file and the listed documents can be opened using "
	" `celsus list --open --found=FILENAME KEYWORDS`."
)
parser_list.add_argument(
	"--found",
	type=str,
	help="Only consider the references listed in this file"
	" (newline separated keys, e.g. DOIs or arXiv IDs)."
)
# 
# remove
parser_remove = subparsers.add_parser("remove")
parser_remove.add_argument(
	"keys",
	metavar="KEYS",
	nargs='+',
	type=str,
	help="Celsus keys of the entries that are to be deleted."
)
parser_remove.add_argument(
	"--noopen",
	action="store_true",
	help="Do not open the viewer."
)
parser_remove.add_argument(
	"--move",
	action="store_true",
	help="Move files into current working directory instead of removing them. "
	"This will overwrite files with the same name in the working directory."
)
# config
parser_config = subparsers.add_parser("config")
parser_config.add_argument(
	"--editor",
	type=str,
	help="Command to open the preferred editor, e.g. vi or nano."
)
parser_config.add_argument(
	"--viewer",
	type=str,
	help="Command for opening documents (mostly pdf), e.g. evince."
)
# Parse
args = parser.parse_args()
if args.command is None or parser.description:
	parser.print_help()
	if args.description:
		print(
			"\n--------------------\n\nReference manager\n\n"
			"Uses unique keys to store scientific references in a database.\n"
			"Keys can be DOIs, arXiv IDs (without the arXiv: prefix!) or manually determined.\n"
			"The bibtex citation is automatically loaded from doi.org, arxiv.org or can be added manually.\n"
			"Files are copied into the repository and renamed consistently to\n\n"
			"<root>/<year>/<author><year>.<suffix>\n\n"
			"Citation keys are automatically generated to <author><year>.\n"
			"Both the citation key and the filename are augmented with \n"
			"lower case letters if multiple references lead to the same key.\n"
			"The user-specific config file is ~/.celsusconfig.\n"
		)
	#
	exit(1)
#


# Imports
import sys
import os
import shutil
import requests
import readline
import celsus
from celsus.utils import (
	get_config,
	write_config,
	get_active_repository,
	ONLY_KEY, BIB, BIB_AND_CONTENT,
	write_celsus_file,
	open_viewer, open_editor
)
from celsus.bibtex import (
	parse,
	doi2bib, arxiv2bib, pdf2key,
	is_doi, is_arxiv,
	empty_bib_article,
	gen_letters
)
from celsus.latex import is_non_ascii, unicode_to_latex


# Execute commands
config = get_config()
if args.command == "use":
	# Create the target directory if non-existent
	path = os.path.abspath(args.path)
	if not os.path.exists(path): os.makedirs(path)
	config["active"] = path
	write_config(config)
#
elif args.command == "add":
	# Check args
	if args.from_dir is None:
		files_and_keys = args.refs
		l = len(files_and_keys)
		if l < 2 or l % 2 != 0:
			raise Exception("Even number of more than two arguments expected.")
		#
	#
	else:
		# Generate list of pdf files
		if not os.path.exists(args.from_dir): raise Exception("Directory does not exist.")
		files_and_keys = []
		for root, dirs, files in os.walk(args.from_dir):
			for filename in files:
				if filename.endswith(".pdf"):
					filepath = os.path.join(root, filename)
					files_and_keys.extend((filepath, '-'))
				#
			#
		#
		l = len(files_and_keys)
	#

	# Get repo and paths
	repository, path = get_active_repository(config, load=ONLY_KEY)

	# Helper functions
	is_alive = lambda process: process is not None and process.poll() is None
	def doi_or_arxiv(key):
		""" Returns a tuple, first element is a function to get the bibtex
			if key is DOI or arXiv ID, else None.
			Second element is bool whether to download the file or not.
		"""
		if is_doi(key):
			return (lambda key: (doi2bib(key), "")), False
		#
		elif is_arxiv(key):
			return (lambda key: arxiv2bib(key)), True
		#
		else:
			return None, False
		#
	#

	# Iterate arguments
	for i in range(0, l, 2):
		filepath, key = files_and_keys[i:i+2]

		# Defaults
		bib = ""
		manual = False
		download = False
		check_key = False
		edit_flag = False
		viewer_proc = None

		# Check if key is given, find out if not
		if key == '-':
			if filepath == '-' or not os.path.exists(filepath):
				print("File {} does not exist.".format(filepath))
				continue
			#
			key = pdf2key(filepath)
			if len(key) == 0:
				viewer_proc = open_viewer(filepath, config)
				key = input("Could not identify key of {}, please find it manually (Skip): ".format(filepath))
				if len(key) == 0: continue
			#
			else: check_key = True
		#

		# Check if already present
		if key in repository:
			print("Reference already loaded.")
			continue
		#

		# Distinguish between DOI, arxiv and manual
		get_bib, download = doi_or_arxiv(key)
		if get_bib is None:
			manual = True
		#

		# Check if file is present
		if not ((filepath == '-' and download) or os.path.exists(filepath)):
			print("File not found \"{}\".".format(filepath))
			print(key, file=sys.stderr)
			continue
		#

		# Download bib
		while not manual: # Sneaky
			bib, url = get_bib(key)
			if len(bib) > 0: break
			ui = input(
				"Could not retrieve bibtex for key {}, file {}"
				", retry? (Skip=s, New key=e, Retry) ".format(key, filepath)
			)
			if ui == 's':
				print(key, file=sys.stderr)
				break
			#
			elif ui == 'e':
				while True:
					key = input("Please enter new key (Skip): ")
					if len(key) == 0: break
					get_bib, download = doi_or_arxiv(key)
					if get_bib is None:
						print("At this point, key must be DOI or arXiv ID.")
						continue
					#
					break
				#
				if len(key) == 0: break
			#
		#
		if len(key) == 0: continue # If manual = False, then key cannot
		# be of length zero by definition

		# Check if bibtex is correct
		if not is_alive(viewer_proc): viewer_proc = open_viewer(filepath, config)
		ui = input(
			"Found this bibtex:\n\n{}\n\nDoes it match the reference? "
			"(Skip=s, Edit=e, Yes)".format(bib)
		)
		if ui == "s":
			print("Could not find a matching bibtex.")
			print(key, file=sys.stderr)
			continue
		#
		elif ui == 'e':
			edit_flag = True
		#

		# Check if manual adjustment is required
		while True:
			has_non_ascii = is_non_ascii(bib)
			if len(bib) == 0 or has_non_ascii or manual or edit_flag:
				if not edit_flag:
					# Ask user what to do
					ui = input(
						((
							"Received invalid bibtex for {}"
							", adjust manually? (Skip=s, Open+Edit=o, Edit) "
						) if not manual else (
							"Key for {} is no DOI or arXiv ID. "
							"Please enter the bibtex manually "
							"(Skip=s, Edit) "
						)).format(filepath)
					)
					if ui == 's':
						print(key, file=sys.stderr)
						bib = ""
						break
					#
					if ui == 'o' and not is_alive(viewer_proc):
						viewer_proc = open_viewer(filepath, config)
					#
				#
				else:
					if not is_alive(viewer_proc): viewer_proc = open_viewer(filepath, config)
				#
				# Change bib to something more reasonable
				if len(bib) == 0:
					bib = empty_bib_article
				#
				elif has_non_ascii:
					bib = unicode_to_latex(
						bib,
						non_ascii_only=True,
						replacement_latex_protection="braces-all",
						unknown_char_warning=False
					)
				#
				# Open file and editor
				tmppath = os.path.join(path, "tmpfile")
				with open(tmppath, "w") as f:
					f.write(bib)
				#
				proc = open_editor(tmppath, config)
				if proc.returncode != 0:
					print("Editor could not be opened successfully.", file=stderr)
					bib = ""
					break
				#
				# Get file contents and remove
				with open(tmppath, "r") as f:
					bib = f.read().strip()
				#
				os.remove(tmppath)
				edit_flag = False
				continue
			#

			# Parse and check if anything wasn't found or if author contains any non-ascii chars
			old_citation_key, author, year = parse(bib)
			if (
			any(v is None for v in (author, year, old_citation_key))
			or is_non_ascii(author)
			):
				ui = input("Could not parse bib (Skip=s, Edit) ")
				if ui == 's':
					bib = ""
					break
				#
				edit_flag = True
			#
			else:
				break
			#
		#
		if len(bib) == 0:
			print("Could not load bib from key {}.".format(key))
			print(key, file=sys.stderr)
			continue
		#

		# Download file if required
		if filepath == '-':
			website = requests.get(url)
			if not website.ok:
				print("Could not load pdf from arXiv: {}.".format(url))
				print("" + key, file=sys.stderr)
				continue
			#
			filepath = os.path.join(path, "tmpfile.pdf")
			with open(filepath, "wb") as f:
				f.write(website.content)
			#
		#

		# Generate a filename from the citation key
		target_dir = os.path.join(path, year)
		found = False
		extension = os.path.splitext(filepath)[1]
		for letter in gen_letters():
			citation_key = author + year + letter
			target_filename = os.path.join(target_dir, citation_key + extension)
			if not os.path.exists(target_filename):
				found = True
				break
			#
		#

		# Modify bib to include citation key
		if isinstance(old_citation_key, str):
			bib = bib.replace(old_citation_key, citation_key, 1)
		#
		else: # In this case the key is integer, indicating where the key should be
			bib = bib[:old_citation_key] + citation_key + bib[old_citation_key:]
		#

		# Generate target path
		if not os.path.exists(target_dir): os.makedirs(target_dir)
		# Move file
		try:
			shutil.move(filepath, target_filename)
		#
		except:
			print("Could not move file {} to {}.".format(filepath, target_filename))
			print(key, file=sys.stderr)
			continue
		#

		# Save changes
		write_celsus_file(target_filename, key, bib)

		# Add to repo
		repository[key] = None # No entry needed, only key
		print("Added {}.".format(key))

		# Close viewer if still open
		if is_alive(viewer_proc): viewer_proc.terminate() 
	#
#
elif args.command == "list":
	if args.found is not None:
		if not os.path.isfile(args.found):
			raise Exception("File {} not found.".format(args.found))
		#
		with open(args.found, "r") as f:
			keys_to_use = f.read().split('\n')
		#
		use_key = lambda key: True if key in keys_to_use else False
	#
	else: use_key = lambda key: True

	if not args.deep:
		# Get repo
		repository, root_path = get_active_repository(config, load=BIB)

		# Set up format string
		fmt_str = []
		if args.file: fmt_str.append("{file}")
		if args.key: fmt_str.append("{key}")
		if not args.nobib: fmt_str.append("{bib}")
		fmt_str = "\n".join(fmt_str)
		# Set up mechanism to open files if required
		to_open = []
		remember_file = (
			(lambda file: to_open.append(file))
			if args.open else
			(lambda file: None)
		)
		# Search and print
		keywords = args.keywords
		for (key, (file, bib, _)) in repository.items():
			if not use_key(key): continue
			if all(k in bib for k in keywords):
				file = os.path.join(root_path, file)
				print(fmt_str.format(key=key, file=file, bib=bib), "\n")
				remember_file(file)
			#
		#
		if not args.open: exit(0)
		# Open files
		number_of_files = len(to_open)
		if number_of_files > 5:
			if input("Open {} files? (Yes=y, No) ".format(number_of_files)) == "":
				exit(0)
			#
		#
		for file in to_open:
			open_viewer(file, config)
		#
	#
	else:
		# Get repo
		repository, root_path = get_active_repository(config, load=BIB_AND_CONTENT)

		# Search
		found = []
		keywords = args.keywords
		for (key, (_, bib, content)) in repository.items():
			if not use_key(key): continue
			if all(k in (bib + '\n' + content) for k in keywords):
				found.append(key)
			#
		#

		# Open files
		number_of_files = len(found)
		if number_of_files > 5:
			if input("Open {} files one after another? (Yes=y, No) ".format(number_of_files)) == "":
				exit(0)
			#
		#
		collected = []
		for key in found:
			open_viewer(os.path.join(root_path, repository[key][0]), config)
			if input("Add reference to list? (No=n, Yes) ") != 'n': collected.append(key)
		#
		collected = '\n'.join(collected)

		# Output
		ui = input("Write keys to file? (Yes=FILENAME, No) ").strip()
		if len(ui):
			with open(ui, "w") as f:
				f.write(collected)
			#
		#
		else:
			print(collected)
		#
	#
#
elif args.command == "remove":
	keys = args.keys
	args_open = not args.noopen

	# Load the repo
	repository, root_path = get_active_repository(config, load=keys)

	# Function to (re)move file
	wd = os.getcwd()
	remove_entry = (
		lambda path: shutil.move(path, os.path.join(wd, os.path.split(path)[1]))
		if args.move else
		lambda path: os.remove(path)
	)
	
	# Iterate given keys
	for key in keys:
		# Check if key there, get path
		if key not in repository:
			print("Key {} not in repository.".format(key), file=sys.stderr)
		#
		path, bib, _ = repository[key]
		path = os.path.join(root_path, path)
		# Ask for user input
		if args_open: open_viewer(path, config)
		ui = input("Remove this entry?\n\n{}\n\n(Yes=y, No)".format(bib))
		if ui != 'y': continue
		# Remove if necessary
		remove_entry(path)
		os.remove(path + ".celsus")
	#
#
elif args.command == "config":
	if args.editor is not None: config["editor"] = args.editor
	if args.viewer is not None: config["viewer"] = args.viewer
	write_config(config)
#

