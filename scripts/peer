#!/usr/bin/env python3
"""

	Peer - Puristic, easy, enjoyable reference-manager

"""

# Parse arguments
import argparse
parser = argparse.ArgumentParser(
	formatter_class=argparse.RawTextHelpFormatter
)
parser.add_argument("--description", action="store_true")
# Add the command subparser
subparsers = parser.add_subparsers(dest="command")
# use
parser_use = subparsers.add_parser(
	"use",
	help="Initialise a new repository or activate an existing one."
)
parser_use.add_argument(
	"path",
	metavar="PATH",
	type=str,
	default='.',
	help="to the repository."
)
# add
parser_add = subparsers.add_parser(
	"add",
	help="Add a document with corresponding unique key to the repository."
)
parser_add.add_argument(
	"-edit",
	action="store_true",
	help="Edit the bibtex before it is parsed, useful if there is an error."
	"Obsolete if no DOI or arXiv ID is used."
)
parser_add.add_argument(
	"refs",
	metavar="REFS",
	nargs='+',
	type=str,
	help="List file1 key1 file2 key2 ... "
	"if adding fails, a message is written into stdout and the filename or key "
	"is written into stderr, depending on the error, no exception will be raised. "
	"If file is \"-\", it must be an arxiv paper which will be downloaded automatically."
)
# list
parser_list = subparsers.add_parser(
	"list",
	help="List matching references, see flags."
)
parser_list.add_argument(
	"keywords",
	metavar="KEYWORDS",
	nargs='*',
	type=str,
	help="List of keywords which must all be present "
	"in a matching bibtex entry (case sensitive)."
)
parser_list.add_argument("-key", action="store_true", help="Print the key.")
parser_list.add_argument(
	"-file",
	action="store_true",
	help="Print the path to the reference's file."
)
parser_list.add_argument("-nobib", action="store_true", help="Don't print the bibtex entry.")
# Parse
args = parser.parse_args()
if args.command is None or parser.description:
	parser.print_help()
	if args.description:
		print(
			"\n--------------------\n\nReference manager\n\n"
			"Uses unique keys to store scientific references in a database.\n"
			"Keys can be DOIs, arXiv IDs (without the arXiv: prefix!) or manually determined.\n"
			"The bibtex citation is automatically loaded from doi.org, arxiv.org or can be added manually.\n"
			"Files are copied into the repository and renamed consistently to\n\n"
			"<root>/<year>/<author><year>.<suffix>\n\n"
			"Citation keys are automatically generated to <author><year>.\n"
			"Both the citation key and the filename are augmented with \n"
			"lower case letters if multiple references lead to the same key.\n"
			"The user-specific config file is ~/.peerconfig.\n"
		)
	#
	exit(1)
#

# Imports
import sys
import os
import shutil
import string
import re
import zlib
import json
import requests
import bs4
import datetime
import bibtexparser
from bibtexparser.bwriter import BibTexWriter
from bibtexparser.bibdatabase import BibDatabase


# Constants
CONFIG_FILE = os.path.expanduser("~/.peerconfig")

# Helpful functions
def read_compressed_json(filename):
	""" zlib compressed json file -> object """
	with open(filename, "rb") as f:
		obj = json.loads(zlib.decompress(f.read()).decode())
	#
	return obj
#

def write_compressed_json(filename, obj):
	""" object -> zlib compressed json file """
	with open(filename, "wb") as f:
		f.write(zlib.compress(json.dumps(obj).encode()))
	#
	return
#

def doi2bib(doi):
	""" string DOI -> bibtex entry string
		
		Loads the bibtex entry from doi.org.
		Returns empty string if failing to do so.
	"""
	website = requests.get(
		"http://dx.doi.org/" + doi,
		headers={"accept": "application/x-bibtex"}
	)
	if not website.ok:
		return ""
	#
	return website.text
#

def arxiv2bib(arxiv_id):
	""" string arxiv_id -> bibtex entry string, pdf url
	
		Loads the bibtex entry from arxiv.org.
		Returns an empty string if failing to do so.
		The prefix "arXiv:" is to be omitted in the ID.
	"""
	website = requests.get("https://arxiv.org/abs/" + arxiv_id)
	if not website.ok:
		return ""
	#
	soup = bs4.BeautifulSoup(website.text, "lxml")
	citation = {
		"archivePrefix": "arXiv",
		"eprint": arxiv_id,
		"author": []
	}
	url = None
	for tag in soup.find_all("meta"):
		name = tag.get("name", None)
		if name is None or name.find("citation") == -1: continue
		name = name.replace("citation_", "")
		if name == "pdf_url":
			url = tag.get("content")
			continue
		#
		if name not in ["title", "author", "date"]: continue
		if name == "author":
			citation["author"].append(tag.get("content"))
		#
		elif name == "date":
			date = tag.get("content")
			date = datetime.datetime.strptime(date, "%Y/%m/%d")
			citation["year"] = date.strftime("%Y")
			citation["month"] = date.strftime("%b").lower()
		#
		else:
			citation[name] = tag.get("content")
		#
	#
	citation["author"] = " and ".join(citation["author"])
	bib = (
		"@article{" + arxiv_id + ",\n"
		+ ",\n".join(["\t{} = {{{}}}".format(key, value) for key, value in citation.items()])
		+ "\n}"
	)
	return bib, url
#

def get_config():
	""" Returns the peer config in a dictionary """
	if not os.path.isfile(CONFIG_FILE):
		config = {}
	#
	else:
		with open(CONFIG_FILE, "r") as f:
			config = json.load(f)
		#
	#
	return config
#

def get_active_repository(config):
	""" Load the active repository.
	
	Arguments:
		> config: dictionary containing the peer config.
	
	Returns:
		> repository: dictionary storing the references.
		> bibs_file: the path to the compressed json file
		  containing repository.
		> path: to the folder containing the repository.
	"""	
	path = config.get("active", None)
	if path is None:
		raise Exception("No active repository.")
	#
	bibs_file = os.path.join(path, "bibs")
	repository = read_compressed_json(bibs_file)
	return repository, bibs_file, path
#

def write_config(config):
	""" Write the peer config into the respective user-unique file """
	with open(CONFIG_FILE, "w") as f:
		json.dump(config, f, sort_keys=True, indent='\t')
	#
	return
#

# Citation key augmentation if there are multiple publications
# from the same author in the same year
def gen_letters():
	""" Generator for letter combinations: '', 'a', 'b', ... 'z', 'aa', 'ab', ... """
	letters = ("",) + tuple(string.ascii_lowercase)
	L = len(letters)
	log_base = np.log(L)
	i = 0
	while True:
		order = int(np.log(max(i,1)) / log_base)
		for k in range(order, 0, -1):
			m = L**k
			if (i % m) == 0:
				i += m // L
			#
		#
		code = ""
		j = i
		for k in range(order, 0, -1):
			m = L**k
			code = letters[j // m] + code
			j = j % m
		#
		yield code + letters[j]
		i += 1
	#
	return # Never happening
#

# Execute commands
config = get_config()
if args.command == "use": 
	# Create the target directory if non-existent
	path = args.path
	if not os.path.exists(path):
		os.makedirs(path)
	#
	# Target directory exists, check it and add required files/folders
	faulty = False
	if len(os.listdir(path)) == 2:
		if not (
		os.path.isfile(os.path.join(path, "bibs"))
		and os.path.isdir(os.path.join(path, "references"))
		):
			faulty = True
		#
	#
	elif len(os.listdir(path)) == 0:
		os.mkdir(os.path.join(path, "references"))
		write_compressed_json(os.path.join(path, "bibs"), {})
	#
	else:
		faulty = True
	#
	if faulty:
		raise Exception("Given directory does not contain a valid repository.")
	#
	else:
		config["active"] = path
		write_config(config)
	#
#
elif args.command == "add":
	# Check args 
	edit_flag = args.edit
	files_and_keys = args.refs
	l = len(files_and_keys)
	if l < 2 or l % 2 != 0:
		raise Exception("Even number of more than two arguments expected.")
	#
	# Get repo and paths
	repository, bibs_file, path = get_active_repository(config)
	# Compile regexes for author, year and citation key from bibtex
	re_accent = re.compile(
		r"{\\("
			"`"
			"|'"	
			"|^"
			"|\""
			"|H"
			"|~"
			"|c"
			"|k"
			"|="
			"|b"
			"|\\."
			"|d"
			"|r"
			"|u"
			"|v"
		")("
			"{[a-zA-Z]}"
			"|[a-zA-Z]"
		")}"
	)
	re_special = re.compile(
		r"{\\("
		"l{}"
		"|l"
		"|t{[a-zA-Z]{2}}"
		"|o{}"
		"|o"
		"|[ij]"
		"|aa"
		"|AA"
		"|ae"
		"|AE"
		"|dh"
		"|DH"
		"|dj"
		"|DJ"
		"|L"
		"|l"
		"|o"
		"|O"
		"|oe"
		"|OE"
		"|ss"
		"|th"
		"|TH"
		")}"
	)
	re_paratheses = re.compile(r"{([a-zA-Z])}")
	re_author = re.compile(r"\s+author[\s={\"]+([\w\-\s\.,]+?)(\s+and\s+|\s*[\"}]).*")
	re_year = re.compile(r"\s*year[\s={\"]+([0-9]+).*")
	re_key = re.compile(r"\s*@[a-zA-Z]+{(.*?),.*")
	re_doi = re.compile(r"[0-9a-zA-Z-]+\.[0-9a-zA-Z-]+/[-;:\.<>()0-9a-zA-Z]+$")
	re_arxiv = re.compile(r"[0-9]{2}(0[1-9]|11|12)\.[0-9]{5}$")
	# Iterate arguments
	for i in range(0, l, 2):
		# Check if in repo
		filepath, key = files_and_keys[i:i+2]
		if key in repository:
			print("Reference already loaded.")
			continue
		#

		# Check if file is present
		if (not filepath == '-') and (not os.path.exists(filepath)):
			print("File not found \"{}\".".format(filepath))
			print("FILE: " + filepath, file=sys.stderr)
			continue
		#

		# Distinguish between DOI, arxiv and manual
		download = False
		bib = ""
		if re_doi.match(key) is not None:
			bib = doi2bib(key)
		#
		elif re_arxiv.match(key) is not None:
			bib, url = arxiv2bib(key)
			download = True
		#
		if len(bib) == 0 or edit_flag:
			tmppath = os.path.join(path, "tmpfile")
			with open(tmppath, "w") as f:
				f.write(bib)
			#
			while True:
				os.system("vi " + tmppath)
				with open(tmppath) as f:
					bib = f.read().strip()
				#
				if len(bib) == 0:
					print("Bibtex empty, retry?")
					if input("(Continue ENTER | Quit q):") == "q":
						break
					#
					continue
				#
				break
			#
			os.remove(tmppath)
		#
		if len(bib) == 0:
			print("Could not load bib from key \"{}\".".format(key))
			print("KEY: " + key, file=sys.stderr)
			continue
		#

		# Parse author, year and citation key from bibtex entry
		author = None
		year = None
		old_citation_key = None
		for line in bib.split("\n"):
			# Remove special characters
			# Note that bibtexparser.latexenc.latex_to_unicode is actually better,
			# if it works, can't rely on that
			line = re_accent.sub(r"\2", line)
			line = re_special.sub(r"\1", line)
			line = re_paratheses.sub(r"\1", line)
			if author is None:
				a = re_author.match(line)
				if a is not None:
					# Would be too easy if there was a single convention
					author = a.groups()[0]
					if ',' in author:
						author = author.split()[0].replace(',', "")
					#
					else:
						author = author.split()[-1]
					#
					continue
				#
			#
			if year is None:
				y = re_year.match(line)
				if y is not None:
					year = y.groups()[0]
				#
				continue
			#
			if old_citation_key is None:
				k = re_key.match(bib)
				if k is not None:
					start = k.start(1)
					end = k.end(1)
					if start != end:
						old_citation_key = bib[start:end]
					#
					else:
						old_citation = start
					#
				#
			#
		#
		# Check if anything wasn't found
		if any(v is None for v in (author, year, old_citation_key)):
			print("Could not parse bib of {}.".format(key))
			print("KEY: " + key, file=sys.stderr)
			continue
		#
		# Generate a filename form the citation key
		target_dir = os.path.join(path, "references", year)
		found = False
		extension = os.path.splitext(filepath)[1]
		for letter in gen_letters():
			citation_key = author + year + letter
			target_filename = os.path.join(target_dir, citation_key + extension)
			if not os.path.exists(os.path.join(target_dir, citation_key)):
				found = True
				break
			#
		#
		# Modify bib to include citation key
		if isinstance(old_citation_key, str):
			bib = bib.replace(old_citation_key, citation_key, 1)
		#
		else:
			bib = bib[:old_citation_key] + citation_key + bib[old_citation_key:]
		#
		# Download file if required
		if filepath == '-':
			website = requests.get(url)
			if not website.ok:
				print("Could not load pdf from arXiv: {}.".format(url))
				print("KEY: " + key, file=sys.stderr)
				continue
			#
			filepath = os.path.join(path, "tmpfile.pdf")
			with open(filepath, "wb") as f:
				f.write(website.content)
			#
		#
		try:
			# Generate target path
			if not os.path.exists(target_dir):
				os.makedirs(target_dir)
			#
			# Move file
			shutil.move(filepath, target_filename)
		#
		except:
			print("Could not move file {} to {}.".format(filepath, target_filename))
			print("KEY: {}".format(key), file=sys.stderr)
			continue
		#
		# Add to repo
		repository[key] = (target_filename, bib)
		print("Added {}.".format(key))
	#
	# Save repo
	write_compressed_json(bibs_file, repository)
#
elif args.command == "list":
	# Get repo
	repository, _, _ = get_active_repository(config)
	# Get args
	keywords = args.keywords
	key_flag = args.key
	file_flag = args.file
	nobib_flag = args.nobib
	# Filter and print references
	fmt_str = []
	if not nobib_flag: fmt_str.append("{bib}")
	if file_flag: fmt_str.append("{file}")
	if key_flag: fmt_str.append("{key}")
	fmt_str = "\n".join(fmt_str)
	for (key, (file, bib)) in repository.items():
		if all(k in bib for k in keywords): 
			print(fmt_str.format(key=key, file=file, bib=bib), "\n")
		#
	#
#

