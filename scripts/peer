#!/usr/bin/env python3
"""

	Peer - Puristic, easy, enjoyable reference-manager

"""

# Parse arguments
import argparse
parser = argparse.ArgumentParser(
	formatter_class=argparse.RawTextHelpFormatter
)
parser.add_argument("--description", action="store_true")
# Add the command subparser
subparsers = parser.add_subparsers(dest="command")
# use
parser_use = subparsers.add_parser(
	"use",
	help="Initialise a new repository or activate an existing one."
)
parser_use.add_argument(
	"path",
	metavar="PATH",
	type=str,
	default='.',
	help="to the repository."
)
# add
parser_add = subparsers.add_parser(
	"add",
	help="Add a document with corresponding DOI to the repository."
)
parser_add.add_argument(
	"refs",
	metavar="REFS",
	nargs='+',
	type=str,
	help="List file1 DOI1 file2 DOI2 ... "
	"if adding fails, a message is written into stdout and the filename or DOI"
	"is written into stderr, depending on the error, no exception will be raised."
)
# list
parser_list = subparsers.add_parser(
	"list",
	help="List matching references, see flags."
)
parser_list.add_argument(
	"keywords",
	metavar="KEYWORDS",
	nargs='*',
	type=str,
	help="List of keywords which must all be present "
	"in a matching bibtex entry (case sensitive)."
)
parser_list.add_argument("-doi", action="store_true", help="Print the DOI.")
parser_list.add_argument(
	"-file",
	action="store_true",
	help="Print the path to the reference's file."
)
parser_list.add_argument("-bib", action="store_true", help="Print the bibtex entry.")
# Parse
args = parser.parse_args()
if args.command is None or parser.description:
	parser.print_help()
	if args.description:
		print(
			"\n--------------------\n\nReference manager\n\n"
			"Uses unique DOIs to store references in a database.\n"
			"Files are copied into the repository and renamed consistently to\n\n"
			"<root>/<year>/<author><year>.<suffix>\n\n"
			"Citation keys are automatically generated to <author><year>.\n"
			"Both the citation key and the filename are augmented with \n"
			"lower case letters if multiple references lead to the same key.\n"
			"The user-specific config file is ~/.peerconfig.\n"
		)
	#	
	exit(1)
#

# Imports
import sys
import os
import requests
import json
import zlib
import shutil
import re
import string

# Constants
CONFIG_FILE = os.path.expanduser("~/.peerconfig")

# Helpful functions
def read_compressed_json(filename):
	""" zlib compressed json file -> object """
	with open(filename, "rb") as f:
		obj = json.loads(zlib.decompress(f.read()).decode())
	#
	return obj
#

def write_compressed_json(filename, obj):
	""" object -> zlib compressed json file """
	with open(filename, "wb") as f:
		f.write(zlib.compress(json.dumps(obj).encode()))
	#
	return
#

def doi2bib(doi):
	""" string DOI -> bibtex entry string
		
		Loads the bibtex entry from doi.org.
		Returns empty string if failing to do so.
	"""
	website = requests.get(
		"http://dx.doi.org/" + doi,
		headers={"accept": "application/x-bibtex"}
	)
	if not website.ok:
		return ""
	#
	return website.text
#

def get_config():
	""" Returns the peer config in a dictionary """
	if not os.path.isfile(CONFIG_FILE):
		config = {}
	#
	else:
		with open(CONFIG_FILE, "r") as f:
			config = json.load(f)
		#
	#
	return config
#

def get_active_repository(config):
	""" Load the active repository.
	
	Arguments:
		> config: dictionary containing the peer config.
	
	Returns:
		> repository: dictionary with DOIs as keys.
		> bibs_file: the path to the compressed json file
		  containing repository.
		> path: to the folder containing the repository.
	"""	
	path = config.get("active", None)
	if path is None:
		raise Exception("No active repository.")
	#
	bibs_file = os.path.join(path, "bibs")
	repository = read_compressed_json(bibs_file)
	return repository, bibs_file, path
#


def write_config(config):
	""" Write the peer config into the respective user-unique file """
	with open(CONFIG_FILE, "w") as f:
		json.dump(config, f, sort_keys=True, indent='\t')
	#
	return
#



# Execute commands
config = get_config()
if args.command == "use": 
	# Create the target directory if non-existent
	path = args.path
	if not os.path.exists(path):
		os.makedirs(path)
	#
	# Target directory exists, check it and add required files/folders
	faulty = False
	if len(os.listdir(path)) == 2:
		if not (
		os.path.isfile(os.path.join(path, "bibs"))
		and os.path.isdir(os.path.join(path, "references"))
		):
			faulty = True
		#
	#
	elif len(os.listdir(path)) == 0:
		os.mkdir(os.path.join(path, "references"))
		write_compressed_json(os.path.join(path, "bibs"), {})
	#
	else:
		faulty = True
	#
	if faulty:
		raise Exception("Given directory does not contain a valid repository.")
	#
	else:
		config["active"] = path
		write_config(config)
	#
#
elif args.command == "add":
	# Check args 
	files_dois = args.refs
	l = len(files_dois)
	if l < 2 or l % 2 != 0:
		raise Exception("Even number of more than two arguments expected.")
	#
	# Get repo and paths
	repository, bibs_file, path = get_active_repository(config)
	# Compile regexes for author, year and citation key from bibtex
	re_author = re.compile("\s+author[\s={\"]+([a-zA-Z\-\s\.,]+?)(\s+and\s+|\s*[\"}]).*")
	re_year = re.compile("\s*year[\s={\"]+([0-9]+).*")
	re_key = re.compile("\s*@[a-zA-Z]+{(.*?),.*")
	# Define letters to augment the citation keys in case of equal author names or
	# multiple publications in the same year
	letters = [""] + list(string.ascii_lowercase)
	# Iterate arguments
	for i in range(0, l, 2):
		filepath, doi = files_dois[i:i+2]
		if doi in repository:
			print("Reference already loaded.")
			continue
		#
		if not os.path.exists(filepath):
			print("File not found \"{}\".".format(filepath))
			print("FILE: " + filepath, file=sys.stderr)
			continue
		#
		bib = doi2bib(doi)
		if len(bib) == 0:
			print("Could not load bib from doi \"{}\".".format(doi))
			print("DOI: " + doi, file=sys.stderr)
			continue
		#
		# Parse author, year and citation key from bibtex entry
		author = None
		year = None
		old_citation_key = None
		for line in bib.split("\n"):
			if author is None:
				a = re_author.match(line)
				if a is not None:
					# Would be too easy if there was a single convention
					author = a.groups()[0]
					if ',' in author:
						author = author.split()[0].replace(',', "")
					#
					else:
						author = author.split()[-1]
					#
					continue
				#
			#
			if year is None:
				y = re_year.match(line)
				if y is not None:
					year = y.groups()[0]
				#
				continue
			#
			if old_citation_key is None:
				k = re_key.match(bib)
				if k is not None:
					start = k.start(1)
					end = k.end(1)
					if start != end:
						old_citation_key = bib[start:end]
					#
					else:
						old_citation = start
					#
				#
			#
		#
		# Check if anything wasn't found
		if any(v is None for v in (author, year, old_citation_key)):
			print("Could not parse bib of {}.".format(doi))
			print("DOI: {}".format(doi), file=sys.stderr)
			continue
		#
		# Generate target path
		target_dir = os.path.join(path, "references", year)
		if not os.path.exists(target_dir):
			os.makedirs(target_dir)
		#
		elif not os.path.isdir(target_dir):
			print("Could not copy file to target.")
			print("TARGET: " + target_dir, file=stderr)
			continue
		#
		# Generate a filename form the citation key
		found = False
		for letter in letters:
			citation_key = author + year + letter
			if not os.path.exists(os.path.join(target_dir, citation_key)):
				found = True
				break
			#
		#
		# Check if successful, sub-optimal but funny
		if not found:
			print("How many {}'s have published something in {}? Not supported :P.".format(author, year))
		#
		# Modify bib to include citation key
		if isinstance(old_citation_key, str):
			bib = bib.replace(old_citation_key, citation_key)
		#
		else:
			bib = bib[:old_citation_key] + citation_key + bib[old_citation_key:]
		#
		# Move file
		target_filename = os.path.join(target_dir, citation_key + os.path.splitext(filepath)[1])
		shutil.move(filepath, target_filename)
		# Add to repo
		repository[doi] = (target_filename, bib)
		print("Added {}.".format(doi))
	#
	# Save repo
	write_compressed_json(bibs_file, repository)
#
elif args.command == "list":
	# Get repo
	repository, _, _ = get_active_repository(config)
	# Get args
	keywords = args.keywords
	doi_flag = args.doi
	file_flag = args.file
	bib_flag = args.bib
	# Filter and print references
	for (doi, (file, bib)) in repository.items():
		if all(k in bib for k in keywords): 
			if doi_flag: print(doi)
			if file_flag: print(file)
			if bib_flag: print(bib)
			print()
		#
	#
#

