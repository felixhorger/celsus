#!/usr/bin/env python3
"""

	Peer - Puristic, easy, enjoyable reference-manager

"""

# Parse arguments
import argparse
parser = argparse.ArgumentParser(
	formatter_class=argparse.RawTextHelpFormatter
)
parser.add_argument("--description", action="store_true")
# Add the command subparser
subparsers = parser.add_subparsers(dest="command")
# use
parser_use = subparsers.add_parser(
	"use",
	help="Initialise a new repository or activate an existing one."
)
parser_use.add_argument(
	"path",
	metavar="PATH",
	type=str,
	default='.',
	help="to the repository."
)
# add
parser_add = subparsers.add_parser(
	"add",
	help="Add a document with corresponding unique key to the repository."
)
parser_add.add_argument(
	"refs",
	metavar="REFS",
	nargs='+',
	type=str,
	help="List file1 key1 file2 key2 ... "
	"if adding fails, a message is written into stdout and the filename or key "
	"is written into stderr, depending on the error, no exception will be raised. "
	"If file is \"-\", it must be an arxiv paper which will be downloaded automatically."
)
# list
parser_list = subparsers.add_parser(
	"list",
	help="List matching references, see flags."
)
parser_list.add_argument(
	"keywords",
	metavar="KEYWORDS",
	nargs='*',
	type=str,
	help="List of keywords which must all be present "
	"in a matching bibtex entry (case sensitive)."
)
parser_list.add_argument("-key", action="store_true", help="Print the key.")
parser_list.add_argument(
	"-file",
	action="store_true",
	help="Print the path to the reference's file."
)
parser_list.add_argument("-nobib", action="store_true", help="Don't print the bibtex entry.")
# Parse
args = parser.parse_args()
if args.command is None or parser.description:
	parser.print_help()
	if args.description:
		print(
			"\n--------------------\n\nReference manager\n\n"
			"Uses unique keys to store scientific references in a database.\n"
			"Keys can be DOIs, arXiv IDs (without the arXiv: prefix!) or manually determined.\n"
			"The bibtex citation is automatically loaded from doi.org, arxiv.org or can be added manually.\n"
			"Files are copied into the repository and renamed consistently to\n\n"
			"<root>/<year>/<author><year>.<suffix>\n\n"
			"Citation keys are automatically generated to <author><year>.\n"
			"Both the citation key and the filename are augmented with \n"
			"lower case letters if multiple references lead to the same key.\n"
			"The user-specific config file is ~/.peerconfig.\n"
		)
	#
	exit(1)
#

# Imports
import sys
import os
import shutil
import string
import re
import zlib
import json
import requests
import bs4
import datetime
import bibtexparser
from bibtexparser.bwriter import BibTexWriter
from bibtexparser.bibdatabase import BibDatabase


# Constants
CONFIG_FILE = os.path.expanduser("~/.peerconfig")

# Helpful functions
def read_compressed_json(filename):
	""" zlib compressed json file -> object """
	with open(filename, "rb") as f:
		obj = json.loads(zlib.decompress(f.read()).decode())
	#
	return obj
#

def write_compressed_json(filename, obj):
	""" object -> zlib compressed json file """
	with open(filename, "wb") as f:
		f.write(zlib.compress(json.dumps(obj).encode()))
	#
	return
#

def doi2bib(doi):
	""" string DOI -> bibtex entry string
		
		Loads the bibtex entry from doi.org.
		Returns empty string if failing to do so.
	"""
	website = requests.get(
		"http://dx.doi.org/" + doi,
		headers={"accept": "application/x-bibtex"}
	)
	if not website.ok:
		return ""
	#
	return website.text
#

def arxiv2bib(arxiv_id):
	""" string arxiv_id -> bibtex entry string, pdf url
	
		Loads the bibtex entry from arxiv.org.
		Returns an empty string if failing to do so.
		The prefix "arXiv:" is to be omitted in the ID.
	"""
	website = requests.get("https://arxiv.org/abs/" + arxiv_id)
	if not website.ok:
		return ""
	#
	soup = bs4.BeautifulSoup(website.text, "lxml")
	citation = {
		"ENTRYTYPE": "article",
		"archivePrefix": "arXiv",
		"eprint": arxiv_id,
		"ID": arxiv_id,
		"author": []
	}
	url = None
	for tag in soup.find_all("meta"):
		name = tag.get("name", None)
		if name is None or name.find("citation") == -1: continue
		name = name.replace("citation_", "")
		if name == "pdf_url":
			url = tag.get("content")
			continue
		#
		if name not in ["title", "author", "date"]: continue
		if name == "author":
			citation["author"].append(tag.get("content"))
		#
		elif name == "date":
			date = tag.get("content")
			date = datetime.datetime.strptime(date, "%Y/%m/%d")
			citation["year"] = date.strftime("%Y")
			citation["month"] = date.strftime("%b").lower()
		#
		else:
			citation[name] = tag.get("content")
		#
	#
	citation["author"] = " and ".join(citation["author"])
	db = BibDatabase()
	db.entries = [citation]
	writer = BibTexWriter()
	writer.indent = '\t'
	print(writer.write(db))
	return writer.write(db), url
#

def get_config():
	""" Returns the peer config in a dictionary """
	if not os.path.isfile(CONFIG_FILE):
		config = {}
	#
	else:
		with open(CONFIG_FILE, "r") as f:
			config = json.load(f)
		#
	#
	return config
#

def get_active_repository(config):
	""" Load the active repository.
	
	Arguments:
		> config: dictionary containing the peer config.
	
	Returns:
		> repository: dictionary storing the references.
		> bibs_file: the path to the compressed json file
		  containing repository.
		> path: to the folder containing the repository.
	"""	
	path = config.get("active", None)
	if path is None:
		raise Exception("No active repository.")
	#
	bibs_file = os.path.join(path, "bibs")
	repository = read_compressed_json(bibs_file)
	return repository, bibs_file, path
#


def write_config(config):
	""" Write the peer config into the respective user-unique file """
	with open(CONFIG_FILE, "w") as f:
		json.dump(config, f, sort_keys=True, indent='\t')
	#
	return
#



# Execute commands
config = get_config()
if args.command == "use": 
	# Create the target directory if non-existent
	path = args.path
	if not os.path.exists(path):
		os.makedirs(path)
	#
	# Target directory exists, check it and add required files/folders
	faulty = False
	if len(os.listdir(path)) == 2:
		if not (
		os.path.isfile(os.path.join(path, "bibs"))
		and os.path.isdir(os.path.join(path, "references"))
		):
			faulty = True
		#
	#
	elif len(os.listdir(path)) == 0:
		os.mkdir(os.path.join(path, "references"))
		write_compressed_json(os.path.join(path, "bibs"), {})
	#
	else:
		faulty = True
	#
	if faulty:
		raise Exception("Given directory does not contain a valid repository.")
	#
	else:
		config["active"] = path
		write_config(config)
	#
#
elif args.command == "add":
	# Check args 
	files_and_keys = args.refs
	l = len(files_and_keys)
	if l < 2 or l % 2 != 0:
		raise Exception("Even number of more than two arguments expected.")
	#
	# Get repo and paths
	repository, bibs_file, path = get_active_repository(config)
	# Compile regexes for author, year and citation key from bibtex
	re_author = re.compile("\s+author[\s={\"]+([\w\-\s\.,]+?)(\s+and\s+|\s*[\"}]).*")
	re_year = re.compile("\s*year[\s={\"]+([0-9]+).*")
	re_key = re.compile("\s*@[a-zA-Z]+{(.*?),.*")
	re_doi = re.compile("[0-9a-zA-Z-]+\.[0-9a-zA-Z-]+/[-\.0-9a-zA-Z]+$")
	re_arxiv = re.compile("[0-9]{2}(0[1-9]|11|12)\.[0-9]{5}$")
	# Define letters to augment the citation keys in case of equal author names or
	# multiple publications in the same year
	letters = [""] + list(string.ascii_lowercase)
	# Iterate arguments
	for i in range(0, l, 2):
		# Check if in repo
		filepath, key = files_and_keys[i:i+2]
		if key in repository:
			print("Reference already loaded.")
			continue
		#

		# Check if file is present
		if (not filepath == '-') and (not os.path.exists(filepath)):
			print("File not found \"{}\".".format(filepath))
			print("FILE: " + filepath, file=sys.stderr)
			continue
		#

		# Distinguish between DOI, arxiv and manual
		download = False
		if re_doi.match(key) is not None:
			bib = doi2bib(key)
		#
		elif re_arxiv.match(key) is not None:
			bib, url = arxiv2bib(key)
			download = True
		#
		else:
			tmppath = os.path.join(path, "tmpfile")
			open(tmppath, "w").close()
			while True:
				os.system("vi " + tmppath)
				with open(tmppath) as f:
					bib = f.read().strip()
				#
				parsed = bibtexparser.loads(bib)
				if len(parsed.entries) != 1:
					print("Bibtex invalid, please retry.")
					if input("(Continue ENTER | Quit q):") == "q":
						break
					#
					continue
				#
				break
			#
			os.remove(tmppath)
		#
		if len(bib) == 0:
			print("Could not load bib from key \"{}\".".format(key))
			print("KEY: " + key, file=sys.stderr)
			continue
		#

		# Parse author, year and citation key from bibtex entry
		author = None
		year = None
		old_citation_key = None
		for line in bib.split("\n"):
			if author is None:
				a = re_author.match(line)
				if a is not None:
					# Would be too easy if there was a single convention
					author = a.groups()[0]
					if ',' in author:
						author = author.split()[0].replace(',', "")
					#
					else:
						author = author.split()[-1]
					#
					continue
				#
			#
			if year is None:
				y = re_year.match(line)
				if y is not None:
					year = y.groups()[0]
				#
				continue
			#
			if old_citation_key is None:
				k = re_key.match(bib)
				if k is not None:
					start = k.start(1)
					end = k.end(1)
					if start != end:
						old_citation_key = bib[start:end]
					#
					else:
						old_citation = start
					#
				#
			#
		#

		# Check if anything wasn't found
		if any(v is None for v in (author, year, old_citation_key)):
			print("Could not parse bib of {}.".format(key))
			print("KEY: " + key, file=sys.stderr)
			continue
		#
		# Generate target path
		target_dir = os.path.join(path, "references", year)
		if not os.path.exists(target_dir):
			os.makedirs(target_dir)
		#
		elif not os.path.isdir(target_dir):
			print("Could not copy file to target, no directory.")
			break # No use to continue
		#
		# Generate a filename form the citation key
		found = False
		for letter in letters:
			citation_key = author + year + letter
			if not os.path.exists(os.path.join(target_dir, citation_key)):
				found = True
				break
			#
		#
		# Check if successful, sub-optimal but funny
		if not found:
			print("How many {}'s have published something in {}? Not supported :P.".format(author, year))
			print("KEY: " + key, file=sys.stderr)
			continue
		#
		# Modify bib to include citation key
		if isinstance(old_citation_key, str):
			bib = bib.replace(old_citation_key, citation_key, 1)
		#
		else:
			bib = bib[:old_citation_key] + citation_key + bib[old_citation_key:]
		#
		# Download file if required
		if filepath == '-':
			website = requests.get(url)
			if not website.ok:
				print("Could not load pdf from arXiv: {}.".format(url))
				print("KEY: " + key, file=sys.stderr)
				continue
			#
			filepath = os.path.join(path, "tmpfile.pdf")
			with open(filepath, "wb") as f:
				f.write(website.content)
			#
		#
		# Move file
		target_filename = os.path.join(target_dir, citation_key + os.path.splitext(filepath)[1])
		shutil.move(filepath, target_filename)
		# Add to repo
		repository[key] = (target_filename, bib)
		print("Added {}.".format(key))
	#
	# Save repo
	write_compressed_json(bibs_file, repository)
#
elif args.command == "list":
	# Get repo
	repository, _, _ = get_active_repository(config)
	# Get args
	keywords = args.keywords
	key_flag = args.key
	file_flag = args.file
	nobib_flag = args.nobib
	# Filter and print references
	fmt_str = ""
	if not nobib_flag: fmt_str = "{bib}" + fmt_str
	if file_flag: fmt_str = "{file}\n" + fmt_str
	if key_flag: fmt_str = "{key}\n" + fmt_str
	for (key, (file, bib)) in repository.items():
		if all(k in bib for k in keywords): 
			print(fmt_str.format(key=key, file=file, bib=bib))
		#
	#
#

